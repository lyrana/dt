/*! \file UserParticleBoundaryFunctions.h

  \brief This file has C++ callback functions to treat boundary-crossing particles.

  This is the source code for a C++ implementation of the Python class
  UserParticleBoundaryFunctions_C.

  Below, the user can define, in order of increasing specificity:
    1. A global default callback function "default_bc()"
    2. A boundary-specific callback function "default_bc_at_boundary()"
    3. A boundary-specific and species-specifies callback function
       "bc_at_boundary_for_species()"

  The most specific function found for a given boundary and species is used.  The
  names of these functions must be manually entered into the bc_function_map below,
  and must be given a Python binding in user_particle_boundary_functions_solib.cpp.

  The object code generated by this file is in the shared library
  user_particle_boundary_functions_solib.so.

  \namespace dnt
  \sa ParticleMeshBoundaryConditions.h user_particle_boundary_functions.solib.cpp

*/

#ifndef USERPARTICLEBOUNDARYFUNCTIONS_H
#define USERPARTICLEBOUNDARYFUNCTIONS_H

#include <iostream>
// uncomment to disable assert()
// #define NDEBUG
#include <cassert>
#include "Pstruct.h"
//#include "ParticleMeshBoundaryConditions.h"

namespace dnt
{

//! Compute inner (dot) product of vectors a and b of length LEN.
/*  
template <size_t LEN>
inline double vec_inner_product(double const *const a, double const *const b)
{
  double sum {0};
  for (size_t i = 0; i < LEN; ++i)
    sum += a[i] * b[i];
  return sum;
}
*/
  //! Compute inner (dot) product of py::array_t<double> a and double[] b of length LEN.
  template <size_t LEN>
    inline double vec_inner_product(py::array_t<double> &a, const double *b)
    {
      auto aproxy = a.unchecked<1>();  
      double sum {0};

      for (size_t i = 0; i < LEN; ++i)
        sum += aproxy(i) * b[i];
      return sum;
    }

  
  /*! \class UserParticleBoundaryFunctions
    \brief This class defines callback functions that treat boundary-crossing particles.

    This is a C++ version of the Python class UserParticleBoundaryFunctions_C.

    See {Particle_Module}ParticleMeshBoundaryConditions_C for the naming scheme for
    particle call-back functions.

    The class is templated on the type of the particle struct (PT) so that we can
    pass a (reference to a) particle struct as a argument to its member functions.

    This class declares the ParticleMeshBoundaryConditions class to be a friend class, so
    that it can access this class's bc_function_map member.

    \param PT is the type of particle struct that this class can operate on.
    \sa Ptype, Pstruct, ParticleMeshBoundaryConditions

  */
  template<Ptype PT>
    class UserParticleBoundaryFunctions
    {
      // This serves as a forward declaration of ParticleMeshBoundaryConditions as
      // well as friending it. This provides access to the private bc_function_map.
      template<Ptype PTX>
        friend class ParticleMeshBoundaryConditions;
      // This is an abbreviation for a type:
      template <Ptype PTY>
        using CallbackFunctionPtr =  void (dnt::UserParticleBoundaryFunctions<PTY>::*)(Pstruct<PTY>&, py::str&, const int, const double *dx, const double, py::array_t<double>&);      
    public:
      //! The one and only user-defined UserParticleBoundaryFunctions ctor.
      /*!

        \param position_coordinates: Example: ['x', 'y',]
        
        \sa Ptype

      */
      // Call example (sphere1D.py):
      //     userPBndFns = UserParticleBoundaryFunctions_C(particle_P.position_coordinates, particle_P.dx)
      UserParticleBoundaryFunctions(py::list& position_coordinates_arg)
        {
          // Get the spatial dimension of the particles
          particle_dimension = position_coordinates_arg.size();
          // Store the string names of the position coordinates.
          for (auto item : position_coordinates_arg)
            {
              position_coordinates.push_back(item.cast<std::string>());
              // or: position_coordinates.push_back(std::string(py::str(item)));
            }
          // Create an std::map of function-names to functions
          // We need these temporaries:
          std::string bcFunctionStr;
          CallbackFunctionPtr<PT> bcFunctionPtr;

          // Manually add each callback function defined in the "public" section
          // below to the map (bc_function_map).
          
          // Add the "default_bc" callback function using these three lines:
          bcFunctionStr = "default_bc";
          bcFunctionPtr = &dnt::UserParticleBoundaryFunctions<PT>::default_bc; // We have to fully qualify the member function name.
          bc_function_map.insert(std::make_pair(bcFunctionStr, bcFunctionPtr));
          // works too:
          // bc_function_map.insert(std::make_pair("default_bc", &dnt::UserParticleBoundaryFunctions<PT>::default_bc));

          // Absorb particles at rmin
          bcFunctionStr = "default_bc_at_rmin";
          bcFunctionPtr = &dnt::UserParticleBoundaryFunctions<PT>::default_bc_at_rmin; // We have to fully qualify the member function name.
          bc_function_map.insert(std::make_pair(bcFunctionStr, bcFunctionPtr));

          // Reflect test_electrons at rmin
          bcFunctionStr = "bc_at_rmin_for_test_electrons";
          bcFunctionPtr = &dnt::UserParticleBoundaryFunctions<PT>::bc_at_rmin_for_test_electrons; // We have to fully qualify the member function name.
          bc_function_map.insert(std::make_pair(bcFunctionStr, bcFunctionPtr));
          
        };
      // UserParticleBoundaryFunctions(position_coordinates, dx):ENDDEF

    private:
      size_t particle_dimension; // The number of spatial coordinates of a particle.
      std::vector<std::string> position_coordinates; // The string names of the spatial coordinates.
      
      // The following variable is a dictionary of functions, indexed by the functions names.
      std::map<std::string, CallbackFunctionPtr<PT>> bc_function_map;
      
      // Scratch for manipulating the particle coordinates and velocities:
      double pcoord[PDIM], pvel[PDIM];
    
    public:
      
      //! Define the default boundary condition for all particles on all boundaries.
      /*!

        \param[in,out] p: A full particle record
        \param[in] species_name (string): This is redundant since the function contains the
                            name of the species, but may be useful for
                            indexing.
        \param[in] facet_index (int): The mesh index of the facet that generated the call
                           to this function.
        \param[in] dx_fraction (double): The fraction of the move vector traveled before
                           the facet was crossed.
        \param[in] facet_normal (py::array_t<double>&): The unit vector normal to the 
                            facet crossed.

        \return: Nothing is returned.
      */
      // Call in particle.h:
      // auto bcFunction = bcFunctionDict[std::make_pair(facValue,species_name)];
      void default_bc(Pstruct<PT>& p, py::str& species_name, const int facet_index, const double dx[], const double dx_fraction, py::array_t<double>& facet_normal)
      {

        //std::cout << "Hello from {UserParticleBoundaryFunctions.h}default_bc" << std::endl;

        // Set the delete flag on the particle
        p.bitflags_ = p.bitflags_ | Pstruct<PT>::DELETE_FLAG;

        // We might want to count the number/charge/energy of deleted particles here
        // before returning.

        return;
      }
      // void default_bc(Pstruct<PT>& p, py::str& species_name, const int facet_index, const double dx[], const double dx_fraction, py::array_t<double>& facet_normal): ENDDEF


      //! Default boundary condition for a particle incident on rmin is to absorb the particle after accounting for it.
      /*!

        The class provides scratch space for this function.

        \param[in] double[] dxOutside: The part of the move-vector past the
                                       reflecting surface.

      */
      void default_bc_at_rmin(Pstruct<PT> &p, py::str &species_name, const int facet_index, const double dx[], const double dx_fraction, py::array_t<double> &facet_normal)
      {

        //std::cout << "Hello from {UserParticleBoundaryFunctions.h}default_bc_at_rmin" << std::endl;

        // Set the delete flag on the particle
        p.bitflags_ = p.bitflags_ | Pstruct<PT>::DELETE_FLAG;

        // We might want to count the number/charge/energy of deleted particles here
        // before returning.
        
        return;
      }
      // void default_bc_at_rmin(Pstruct<PT>& p, py::str& species_name, const int facet_index, const double dx[], const double dx_fraction, py::array_t<double>& facet_normal): ENDDEF

      //! Default boundary condition for a particle incident on rmin is to reflect the particle after accounting for it.
      /*!

        The class provides scratch space for this function.

        \param[in] double[] dxOutside: The part of the move-vector past the
                                       reflecting surface.

      */
      void bc_at_rmin_for_test_electrons(Pstruct<PT> &p, py::str &species_name, const int facet_index, const double dx[], const double dx_fraction, py::array_t<double> &facet_normal)
      {

        //std::cout << "Hello from {UserParticleBoundaryFunctions.h}bc_at_rmin_for_test_electrons" << std::endl;

        // Scratch space
        // pcoord can hold: x,y,z, (or subset)
        auto dxOutside = pcoord;
 
        // Compute the move-vector past the reflecting surface
        for (size_t i = 0; i < PDIM; i++)
          {
            dxOutside[i] = (1.0 - dx_fraction)*dx[i];
          }

        p.reflect_from_surface(facet_normal, dxOutside);
        
        return;
      }
      // void bc_at_rmin_for_test_electrons(Pstruct<PT>& p, py::str& species_name, const int facet_index, const double dx[], const double dx_fraction, py::array_t<double>& facet_normal): ENDDEF
      
    };
  // class UserParticleBoundaryFunctions: ENDCLASS

} // namespace dnt


#endif
