/*! \file UserParticleBoundaryFunctions.h

  \brief This file has C++ callback functions to treat boundary-crossing particles.

  This is the source code for a C++ implementation of the Python class
  UserParticleBoundaryFunctions_C.

  Below, the user can define, in order of increasing specificity:
    1. A global default callback function "default_bc()"
    2. A boundary-specific callback function "default_bc_at_boundary()"
    3. A boundary-specific and species-specifies callback function
       "bc_at_boundary_for_species()"

  The most specific function found for a given boundary and species is used.  The
  names of these functions must be manually entered into the bc_function_map below,
  and must be given a Python binding in user_particle_boundary_functions_solib.cpp.

  The object code generated by this file is in the shared library
  user_particle_boundary_functions_solib.so.

  \namespace dnt
  \sa ParticleMeshBoundaryConditions.h user_particle_boundary_functions.solib.cpp

*/

#ifndef USERPARTICLEBOUNDARYFUNCTIONS_H
#define USERPARTICLEBOUNDARYFUNCTIONS_H

#include <iostream>
// uncomment to disable assert()
// #define NDEBUG
#include <cassert>
#include "Pstruct.h"
//#include "ParticleMeshBoundaryConditions.h"

namespace dnt
{
  /*! \class UserParticleBoundaryFunctions
    \brief This class defines callback functions that treat boundary-crossing particles.

    This is a C++ version of the Python class UserParticleBoundaryFunctions_C.

    See {Particle_Module}ParticleMeshBoundaryConditions_C for the naming scheme for
    particle call-back functions.

    The class is templated on the type of the particle struct (PT) so that we can
    pass a (reference to a) particle struct as a argument to its member functions.

    This class declares the ParticleMeshBoundaryConditions class to be a friend class, so
    that it can access this class's bc_function_map member.

    \param PT is the type of particle struct that this class can operate on.
    \sa Ptype, Pstruct, ParticleMeshBoundaryConditions

  */
  template<Ptype PT>
    class UserParticleBoundaryFunctions
    {
      // This serves as a forward declaration of ParticleMeshBoundaryConditions as
      // well as friending it. This provides access to the private bc_function_map.
      template<Ptype PTX>
        friend class ParticleMeshBoundaryConditions;
      // This is an abbreviation for a type:
      template <Ptype PTY>
        using CallbackFunctionPtr =  void (dnt::UserParticleBoundaryFunctions<PTY>::*)(Pstruct<PTY>&, py::str&, const int, const double *dx, const double, py::array_t<double>&);      
    public:
      //! The one and only user-defined UserParticleBoundaryFunctions ctor.
      /*!

        \param position_coordinates: Example: ['x', 'y',]
        
        \sa Ptype

      */
      // Call example (sphere1D.py):
      //     userPBndFns = UserParticleBoundaryFunctions_C(particle_P.position_coordinates, particle_P.dx)
      UserParticleBoundaryFunctions(py::list& position_coordinates_arg)
        {
          for (auto item : position_coordinates_arg)
            {
              position_coordinates.push_back(item.cast<std::string>());
              // or: position_coordinates.push_back(std::string(py::str(item)));
            }
          // Create an std::map of function-names to functions
          // We need these temporaries:
          std::string bcFunctionStr;
          CallbackFunctionPtr<PT> bcFunctionPtr;

          // Manually add each callback function defined in the "public" section
          // below to the map (bc_function_map).
          
          // Add the "default_bc" callback function using these three lines:
          bcFunctionStr = "default_bc";
          bcFunctionPtr = &dnt::UserParticleBoundaryFunctions<PT>::default_bc; // We have to fully qualify the member function name.
          bc_function_map.insert(std::make_pair(bcFunctionStr, bcFunctionPtr));
          // works too:
          // bc_function_map.insert(std::make_pair("default_bc", &dnt::UserParticleBoundaryFunctions<PT>::default_bc));

          // Reflect particles at rmin
          bcFunctionStr = "default_bc_at_rmin";
          bcFunctionPtr = &dnt::UserParticleBoundaryFunctions<PT>::default_bc_at_rmin; // We have to fully qualify the member function name.
          bc_function_map.insert(std::make_pair(bcFunctionStr, bcFunctionPtr));
          
        };
      // UserParticleBoundaryFunctions(position_coordinates, dx):ENDDEF

    private:
      std::vector<std::string> position_coordinates;
      // The following variable is a dictionary of functions, indexed by the functions names.
      std::map<std::string, CallbackFunctionPtr<PT>> bc_function_map;
      
      // Scratch for manipulating the particle coordinates and velocities:
      double pcoord[3], pvel[3];
    
      //! Define the default boundary condition for all particles on all boundaries.
      /*!

        \param p: A full particle record
        \param species_name (string): This is redundant since the function contains the
                            name of the species, but may be useful for
                            indexing.
        \param facet_index (int): The mesh index of the facet that generated the call
                           to this function.
        \param dx_fraction (double): The fraction of the move vector traveled before
                           the facet was crossed.
        \param facet_normal (double[]): The unit vector normal to the facet crossed.

        \return: Nothing is returned.
      */
      // Call in particle.h:
      // auto bcFunction = bcFunctionDict[std::make_pair(facValue,species_name)];

    public:
      void default_bc(Pstruct<PT>& p, py::str& species_name, const int facet_index, const double dx[], const double dx_fraction, py::array_t<double>& facet_normal)
      {

        //std::cout << "Hello from {UserParticleBoundaryFunctions.h}default_bc" << std::endl;

        // Set the delete flag on the particle
        p.bitflags_ = p.bitflags_ | Pstruct<PT>::DELETE_FLAG;

        // We might want to count the number/charge/energy of deleted particles here
        // before returning.

        return;
      }
      // void default_bc(Pstruct<PT>& p, py::str& species_name, const int facet_index, const double dx[], const double dx_fraction, py::array_t<double>& facet_normal): ENDDEF

      void default_bc_at_rmin(Pstruct<PT>& p, py::str& species_name, const int facet_index, const double dx[], const double dx_fraction, py::array_t<double>& facet_normal)
      {

        //std::cout << "Hello from {UserParticleBoundaryFunctions.h}default_bc_at_rmin" << std::endl;

        // Set the delete flag on the particle
        p.bitflags_ = p.bitflags_ | Pstruct<PT>::DELETE_FLAG;

        // We might want to count the number/charge/energy of deleted particles here
        // before returning.

        return;
      }
      // void default_bc_at_rmin(Pstruct<PT>& p, py::str& species_name, const int facet_index, const double dx[], const double dx_fraction, py::array_t<double>& facet_normal): ENDDEF
      
    };
  // class UserParticleBoundaryFunctions: ENDCLASS

} // namespace dnt


#endif
