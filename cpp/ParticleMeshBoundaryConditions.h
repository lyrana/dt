/*! \file ParticleMeshBoundaryConditions.h

  \brief This file defines the C++ type ParticleMeshBoundaryConditions, which
  contains the mapping from mesh-facet tags to the callback functions treating
  particles that cross the facets.

  This is the source code for a C++ implementation of the Python class
  ParticleMeshBoundaryConditions_C.

  The callback functions themselves are defined in UserParticleBoundaryFunctions.h, and
  their Python bindings are in user_particle_boundary_functions_solib.cpp.  The
  ParticleMeshBoundaryConditions class is declared a friend of
  UserParticleBoundaryFunctions class, to give it access to the bc_function_map member.

  The object code generated by this file is in particle_solib.so.  The map contained
  in this class is used in particle.h to apply particle boundary-conditions on a
  mesh.

  \namespace dnt
  \sa UserParticleBoundaryFunctions.h, user_particle_boundary_functions_solib.cpp, particle.h particle_solib.cpp

*/

#ifndef PARTICLEMESHBOUNDARYCONDITIONS_H
#define PARTICLEMESHBOUNDARYCONDITIONS_H

#include <iostream>
// uncomment to disable assert()
// #define NDEBUG
#include <cassert>
#include "Pstruct.h"
#include "UserParticleBoundaryFunctions.h"

namespace dnt
{
  /*! \class ParticleMeshBoundaryConditions

    \brief This class contains a map from mesh-facet tags and species names to callback
           functions.

    The map from facet tags to boundary-condition callback functions is called
    *bc_function_dict*. It's created by using the *bc_function_map* stored in a
    UserParticleBoundaryFunctions object, which associates function-names with
    functions. This object is passed in as an argument to the ctor.

    This is a C++ version of the Python class ParticleMeshBoundaryConditions_C.
  */
  template<Ptype PT>    
    class ParticleMeshBoundaryConditions
    {
      // Make an abbreviation for the type "pointer to particle boundary-condition
      // callback function":
      template <Ptype PTX>      
        using CallbackFunctionPtr =  void (dnt::UserParticleBoundaryFunctions<PTX>::*)(Pstruct<PTX>&, py::str&, const int, const double *dx, const double, py::array_t<double>&);        

    public:

      UserParticleBoundaryFunctions<PT> user_particle_boundary_functions;
      // The following map (dictionary) contains a pointer to a boundary callback
      // function for each [boundary tag][species] pair (i.e., the key is a 2D object).
      // std::map<std::pair<int, std::string>, CallbackFunctionPtr<PT>> bc_function_dict;
      std::map<std::pair<int, std::string>, CallbackFunctionPtr<PT>> bc_function_dict;

      //! The one and only user-defined ParticleMeshBoundaryConditions ctor.
      /*!

        Create a map from facet tags to callback functions. This is how particle boundary
        conditions are implemented. The facet tags are the values of a dolfin FacetFunction
        defined on mesh facets.
      
        The callback functions are named according to the following naming-scheme:
        default_bc(): The default function for all species at all boundaries.
        default_bc_at_name(): The default called for all species at
        the boundary 'name'.
        bc_at_name_for_species: The function called for 'species' crossing 'name'.

        The most specific function found for a given boundary and species is used, and is
        inserted into bc_function_dict.

        \param species_names: Species names in an std::vector<std::string>

        \param pmesh_M: The Mesh_C object use by the particle advance.

        \param userPBFs: A UserParticlesBoundaryFunctions object that contains the callback
        functions for particle boundary-conditions.


        \sa Ptype

      */
    ParticleMeshBoundaryConditions(std::vector<std::string>& species_names, py::object pmesh_M, UserParticleBoundaryFunctions<PT> userPBFs, bool print_flag = false)
      : user_particle_boundary_functions(userPBFs)
      {

        // Set local names from passed parameters
        // pBDict maps boundary names to integers: e.g. 'xmin': 1
        auto pBDict = pmesh_M.attr("particle_boundary_dict").cast<std::map<std::string, int>>();
        /*
          We want to associate the names of the user-supplied boundary functions with
          the int values of the facet tags.  First, we swap the BC dictionary keys
          and values: e.g., change 'xmin':1 to 1:'xmin'. This lets us use the value
          of the facet function, a uint (size_t), as an index to get the string name
          of the boundary.
        */
        std::map<int, std::string> pBDictInv; // The reversed dictionary
        for (auto it : pBDict)
          pBDictInv[it.second] = it.first;

        // Get a list of the integer key values in pBDictInv:
        std::vector<int> particleBoundaryTags;
        for(auto it : pBDictInv)
          {
            particleBoundaryTags.push_back(it.first);
            //std::cout << it.first << std::endl;
          }        

        // Initialize the dictionary that will contain the name of a boundary callback
        // function for each [boundary tag][species] pair (i.e., the key is a 2D object).
        // Use a std::pair as the key [boundary-tag][species-name] index:

        // Find the default boundary function for all boundaries and all species
        // (if there is one) in the UserParticleBoundaryFunctions object passed in.
        // These local variables are used to search for callback functions:
        std::string bcFunctionName;
        CallbackFunctionPtr<PT> bcFunctionPtr, bcGlobalDefaultFunctionPtr, bcBoundaryDefaultFunctionPtr;
        // Create a short alias for the BC function map passed in:
        std::map<std::string, CallbackFunctionPtr<PT>> bcFunctionMap = userPBFs.bc_function_map;
 
        // Check if a global default BC function has been defined:
        bcFunctionName = "default_bc";
        auto it = bcFunctionMap.find(bcFunctionName);          
        if(it != bcFunctionMap.end())
          {
            bcGlobalDefaultFunctionPtr = it->second;
          }
        else
          {
            bcGlobalDefaultFunctionPtr = nullptr;
          }
 
        // Now loop on particle boundary tags and on particle species names to find
        // the most specific BC. Overwrite the default function with a
        // boundary-and-species-specific function, if there is one.
        //          for (std::vector<int>::iterator intTag = particleBoundaryTags.begin(); intTag != particleBoundaryTags.end(); intTag++)
        for (auto intTag : particleBoundaryTags)
          {
            // Create the name of a callback function specific to this boundary.
            ///            bcFunctionName = std::string("default_bc_at_") + pBDictInv[*intTag];
            bcFunctionName = std::string("default_bc_at_") + pBDictInv[intTag];            
            // Search for a function with this name.
            auto it = bcFunctionMap.find(bcFunctionName);
            if(it != bcFunctionMap.end())
              {
                bcBoundaryDefaultFunctionPtr = it->second;
              }
            else
              {
                bcBoundaryDefaultFunctionPtr = bcGlobalDefaultFunctionPtr;
              }

            for (auto sp : species_names)
              {
                // Create the name of a callback function specific to this boundary and
                // species.
                bcFunctionName = std::string("bc_at_") + pBDictInv[intTag] + "_for_" + sp;
                // Search for a function with this name.
                auto it = bcFunctionMap.find(bcFunctionName);
                if(it != bcFunctionMap.end())
                  {
                    bcFunctionPtr = it->second;
                  }
                else
                  {
                    bcFunctionPtr = bcBoundaryDefaultFunctionPtr;
                  }
                // Complain if no callback at all has been found.
                if (bcFunctionPtr == nullptr)
                  {
                    // There's no boundary-condition for this species at this boundary.
                    std::cout << "{ParticleMeshBoundaryConditions.h}ParticleMeshBoundaryConditions(): No callback function was specified for " << pBDictInv[intTag] << "/" << sp << std::endl;
                    std::exit(EXIT_FAILURE);
                  }
                else if (print_flag == true)
                  {
                    std::cout << "{ParticleMeshBoundaryConditions.h}ParticleMeshBoundaryConditions(): Callback function for " << pBDictInv[intTag] << "/" << sp << " is " << bcFunctionName << std::endl;
                  }
                // Finally, store the most-specific callback in the dictionary:
                bc_function_dict[std::make_pair(intTag,sp)] = bcFunctionPtr;
              } // Loop on species
          } // Loop on boundary tags
          
      } // ParticleMeshBoundaryConditions(std::vector<std::string>& species_names, py::object pmesh_M, UserParticleBoundaryFunctions<PT> userPBFs, bool print_flag = false): ENDDEF

    }; // class ParticleMeshBoundaryConditions: ENDCLASS
  
} // namespace dnt
        
#endif
