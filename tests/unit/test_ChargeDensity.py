#!/usr/bin/env python3

__version__ = 0.1
__author__ = 'Copyright (C) 2016 L. D. Hughes'
#__all__ = []

import sys
import os
import math
import unittest
import numpy as np_m

import dolfin as df_m
import matplotlib.pyplot as mplot_m

from Dolfin_Module import Mesh_C
from Dolfin_Module import Field_C

from Particle_Module import *

# Here's the user's mesh definition for the 2D test
from UserMesh_y_Fields_FE_XYZ_Module import *

from UserUnits_Module import MyPlasmaUnits_C

class TestChargeDensity(unittest.TestCase):
    """Test the particle-to-field functions in class Field_C

       See test_ChargeDensity.ods
"""
    
    def setUp(self):
        # initializations for each test go here...

        return

#class TestChargeDensity(unittest.TestCase):
    def test_1_interpolate_particle_density_to_1Dmesh(self):
        """Compute the number-density generated by planar sheet particles.

           Macroparticles are created within a 1D meshed region and are weighted
           to nodal points on the mesh.
           
           No species data is defined for the particles.  
           No segmented-array particle storage is used for the particles, just
           one numpy array is used, with a particle dtype.

           See test_ChargeDensity.ods:test_1 for calculated values of the density.

        """

        fncName = '('+__file__+') ' + sys._getframe().f_code.co_name + '():\n'
        print('\ntest: ', fncName, '('+__file__+')')
        
        # Create a 1D mesh from -0.5 to 0.5
        mesh = df_m.IntervalMesh(2, -0.5, 0.5)
        coordinateSystem = 'Cartesian'

        mesh1d_M = Mesh_C(Mesh=mesh, coordinate_system=coordinateSystem, compute_dictionaries=True, compute_tree=True, plot_flag=False)

        # Put 3 DT particles in the meshed region.

        x0 = -0.25; y0 = 0.0; z0 = 0.0
        ux0 = 0.0; uy0 = 0.0; uz0 = 0.0
        weight0 = 2.0e10 # number of electrons per macroparticle
        bitflags0 = 0b0
        cell_index0 = 0
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        p0 = (x0,y0,z0, ux0,uy0,uz0, weight0, bitflags0, cell_index0, unique_ID, crossings)

        # 2nd particle
        x1 = 0.25; y1 = 0.0; z1 = 1.0
        ux1 = uy1 = 0.0; uz1 = -uz0
        weight1 = 3.0e10
        bitflags1 = 0b0
        cell_index1 = 1
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        p1 = (x1,y1,z1, ux1,uy1,uz1, weight1, bitflags1, cell_index1, unique_ID, crossings)

        # 3nd particle
        x2 = 0.0; y2 = 0.0; z2 = 1.0
        ux2 = uy2 = 0.0; uz2 = -uz0
        weight2 = 4.0e10
        bitflags2 = 0b0
        cell_index2 = 0 # Particle lies on boundary between 0 and 1
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        p2 = (x2,y2,z2, ux2,uy2,uz2, weight2, bitflags2, cell_index2, unique_ID, crossings)

        # Create the DT particle record type
        pvars = ['x', 'y', 'z', 'ux', 'uy', 'uz', 'weight', 'bitflags', 'cell_index', 'unique_ID', 'crossings']
        pvartypes = [np_m.float64]*7
        pvartypes.append(np_m.int32) # bitflags
        pvartypes.append(np_m.int32) # cell_index
        pvartypes.append(np_m.int32) # unique_ID
        pvartypes.append(np_m.int32) # crossings

        p_dtype = {'names' : pvars, 'formats': pvartypes}

        # Put the particles into an ndarray with the above type
        nparticles = 3
        particles = np_m.empty(nparticles, dtype=p_dtype)
        particles[0] = p0
        particles[1] = p1
        particles[2] = p2

        # Allocate storage for the number-density values.  The
        # number-density array stores the integral of the physical
        # particle weight-distribution times the element basis
        # functions.

        dofNumberDensityElementType = 'Lagrange'
        dofNumberDensityElementDegree = 1
        dofNumberDensityFieldType = 'scalar'
        dofNumberDensity_F = Field_C(mesh1d_M,
                                     element_type=dofNumberDensityElementType,
                                     element_degree=dofNumberDensityElementDegree,
                                     field_type=dofNumberDensityFieldType)

#        print "size of dofNumberDensity:", dofNumberDensity.function.vector().size()

        # The expected number-density values are put into a numpy array
        dofNumberDensityExpected = np_m.empty(dofNumberDensity_F.function.vector().size(), dtype=np_m.float64)

        # Note that these are in the vertex numbering order, not DoF order. We will
        # need to compare dofNumberDensityExpected[ivert] with dofNumberDensityCalc[idof],
        # where idof is the DoF number corresponding to ivert (see conversion below).
        dofNumberDensityExpected[0] = 1.0e10
        dofNumberDensityExpected[1] = 6.5e10
        dofNumberDensityExpected[2] = 1.5e10

        for p in particles:
            dofNumberDensity_F.integrate_delta_function(p) # This uses dolfin.PointSource(), which does a search for the cell containing p.
#            dofNumberDensity_F.interpolate_delta_function_to_dofs(p) # This doesn't have to search for the cell containing p.

        # array() returns a numpy array that has a copy of the values in vector().
        dofNumberDensityCalc = dofNumberDensity_F.function.vector().get_local()
#        print dofNumberDensityCalc

        # Compare results
        functionSpace = dofNumberDensity_F.function_space
        gdim = dofNumberDensity_F.mesh_gdim
        # Reshape the coordinates to get (x), or (x,y), or (x,y,z) tuples. The
        # index "-1" is short-hand for the last element of the array.
        if df_m.__version__ > "1.5.0":
            dofcoords = functionSpace.tabulate_dof_coordinates().reshape((-1, gdim))
        else:
            print('\n!!!WARNING!!!: ', fncName, ": DOLFIN too old.  Skipping rest of test")
            return


#        print "dofcoords=", dofcoords

        # Convert vertex indices to DoF indices.  For CG1 elements, there are
        # the same number of vertices as DoFs, and the DoFs are associated with
        # the vertices.
        v2d=df_m.vertex_to_dof_map(functionSpace)

        for ivert in range(len(dofNumberDensityExpected)):
            idof = v2d[ivert]
#            print "vertex", ivert, "is DoF index", idof
#            print "dofNumberDensityCalc, dofNumberDensityExpected =", dofNumberDensityCalc[idof], dofNumberDensityExpected[ivert]
            self.assertAlmostEqual(dofNumberDensityCalc[idof], dofNumberDensityExpected[ivert], places=3, msg="Wrong value of dofNumberDensity")

        return
#    def test_1_interpolate_particle_density_to_1Dmesh(self):ENDDEF

#class TestChargeDensity(unittest.TestCase):
    def test_2_interpolate_particle_density_to_2Dmesh(self):
        """Compute the number-density generated by line particles on a 2D mesh

           Macroparticles are created within a 2D meshed region and are weighted
           to nodal points on the mesh.
           
           No species data is defined for the particles.  
           No segmented-array particle storage is used for the particles, just
           one numpy array is used, with a particle dtype.

           See test_ChargeDensity.ods:test_2 for calculated values of the
           density.

        """

        fncName = '('+__file__+') ' + sys._getframe().f_code.co_name + '():\n'
        print('\ntest: ', fncName, '('+__file__+')')
        
        # Describe a 2D mesh from (-10,-10) to (10,10) with 2 cells on a side.
        # The mesh is triangular, so there's a total of 4x2 = 8 cells.
        umi2d_I = UserMeshInput_C()
        umi2d_I.pmin = df_m.Point(-10.0, -10.0)
        umi2d_I.pmax = df_m.Point(10.0, 10.0)
        umi2d_I.cells_on_side = (2, 2)
        umi2d_I.diagonal = 'left'

        # UserMesh_FE_XYZ_Module can make the mesh from the above input.
        plotFlag = False
        plotTitle = os.path.basename(__file__) + ": " + sys._getframe().f_code.co_name + ": XY mesh"

        pmesh2d_M = UserMesh_C(umi2d_I, compute_dictionaries=True, compute_tree=True, plot_flag=plotFlag, plot_title=plotTitle)
#        pmesh2d_M.compute_cell_vertex_dict()
#        pmesh2d_M.compute_cell_dict()

        # Put 3 particles inside the meshed region

        x0 = -5.0; y0 = -5.0; z0 = 0.0
        ux0 = 0.0; uy0 = 0.0; uz0 = 0.0
        weight0 = 2.0e10 # number of electrons per macroparticle
        bitflags0 = 0b0
        cell_index0 = 1
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        p0 = (x0,y0,z0, ux0,uy0,uz0, weight0, bitflags0, cell_index0, unique_ID, crossings)

        # 2nd particle
        x1 = 1.0; y1 = 1.0; z1 = 1.0
        ux1 = uy1 = 0.0; uz1 = -uz0
        weight1 = 3.0e10
        bitflags1 = 0b0
        cell_index1 = 6
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        p1 = (x1,y1,z1, ux1,uy1,uz1, weight1, bitflags1, cell_index1, unique_ID, crossings)

        # 3nd particle
        x2 = -9.0; y2 = 1.0; z2 = 1.0
        ux2 = uy2 = 0.0; uz2 = -uz0
        weight2 = 4.0e10
        bitflags2 = 0b0
        cell_index2 = 4 # Particle lies on boundary between 0 and 1
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        p2 = (x2,y2,z2, ux2,uy2,uz2, weight2, bitflags2, cell_index2, unique_ID, crossings)

        # Create the DT particle record type
        pvars = ['x', 'y', 'z', 'ux', 'uy', 'uz', 'weight', 'bitflags', 'cell_index', 'unique_ID', 'crossings']
        pvartypes = [np_m.float64]*7
        pvartypes.append(np_m.int32) # bitflags
        pvartypes.append(np_m.int32) # cell_index
        pvartypes.append(np_m.int32) # unique_ID
        pvartypes.append(np_m.int32) # crossings

        p_dtype = {'names' : pvars, 'formats': pvartypes}

        # Put the particles into an ndarray with the above type
        nparticles = 3
        particles = np_m.empty(nparticles, dtype=p_dtype)
        particles[0] = p0
        particles[1] = p1
        particles[2] = p2

        ###### DoF density vector
        
        # Allocate storage for the number-density values.  The number-density array
        # stores the integral of the physical density-distribution times the element
        # basis functions.

        dofNumberDensityElementType = 'Lagrange'
        dofNumberDensityElementDegree = 1
        dofNumberDensityFieldType = 'scalar'
        dofNumberDensity_F = Field_C(pmesh2d_M,
                                  element_type=dofNumberDensityElementType,
                                  element_degree=dofNumberDensityElementDegree,
                                  field_type=dofNumberDensityFieldType)

#        print "size of dofNumberDensity:", dofNumberDensity_F.function.vector().size()

        # The expected number-density values from test_ChargeDensity.ods:test_2
        dofNumberDensityExpected = np_m.empty(dofNumberDensity_F.function.vector().size(), dtype=np_m.float64)

        # Note that these are in the vertex numbering order, not DoF order. We will
        # need to compare dofNumberDensityExpected[ivert] with dofNumberDensityCalc[idof],
        # where idof is the DoF number corresponding to ivert (see conversion below).
        dofNumberDensityExpected[0] = 0.0
        dofNumberDensityExpected[1] = 1.0e10
        dofNumberDensityExpected[2] = 0.0
        dofNumberDensityExpected[3] = 4.2e10
        dofNumberDensityExpected[4] = 2.8e10
        dofNumberDensityExpected[5] = 3.0e9
        dofNumberDensityExpected[6] = 4.0e9
        dofNumberDensityExpected[7] = 3.0e9
        dofNumberDensityExpected[8] = 0.0

        # Compute the DoF density vector using the DnT functions we're testing here.
        for p in particles:
            dofNumberDensity_F.interpolate_delta_function_to_dofs(p)

        # Get a numpy array of the calculated values
        dofNumberDensityCalc = dofNumberDensity_F.function.vector().get_local()
#        print fncName, dofNumberDensityCalc

        functionSpace = dofNumberDensity_F.function_space
        gdim = dofNumberDensity_F.mesh_gdim
        # Reshape the coordinates to get (x), or (x,y), or (x,y,z) tuples.
        if df_m.__version__ > "1.5.0":
            dofcoords = functionSpace.tabulate_dof_coordinates().reshape((-1, gdim))
        else:
            print('\n!!!WARNING!!!: ', fncName, ": DOLFIN too old.  Skipping rest of test")
            return

#        print "dofcoords=", dofcoords

        # Plot the result

        plotTitle = os.path.basename(__file__) + ": " + sys._getframe().f_code.co_name + ": number density"
        df_m.plot(dofNumberDensity_F.function, title=plotTitle)
        mplot_m.show()
#        yesno = raw_input("Just called show() in test_2_interpolate_particle_density_to_2Dmesh")

        ## Check the values vs. those computed in test_ChargeDensity.ods:test_2

        # Convert vertex indices to DoF indices.  For CG1 elements, there are
        # the same number of vertices as DoFs.
        v2d=df_m.vertex_to_dof_map(functionSpace)

        for ivert in range(len(dofNumberDensityExpected)):
            idof = v2d[ivert] # The DoF number for this vertex.
#            print "vertex", ivert, "is DoF index", idof
#            print "dofNumberDensityCalc, dofNumberDensityExpected =", dofNumberDensityCalc[idof], dofNumberDensityExpected[ivert]
            # "places" means numbers after the decimal point:
            self.assertAlmostEqual(dofNumberDensityCalc[idof], dofNumberDensityExpected[ivert], places=4, msg="Wrong value of dofNumberDensity")


        ###### Cell density vector

        # Allocate storage for the cell number-density values.

        cellNumberDensityElementType = 'DG'
        cellNumberDensityElementDegree = 0
        cellNumberDensityFieldType = 'scalar'
        cellNumberDensity_F = Field_C(pmesh2d_M,
                                      element_type=cellNumberDensityElementType,
                                      element_degree=cellNumberDensityElementDegree,
                                      field_type=cellNumberDensityFieldType)

#        print "size of cellNumberDensity:", cellNumberDensity_F.function.vector().size()

        # Compute the cell density using the DnT functions that we're testing
        for p in particles:
            cellNumberDensity_F.add_weight_to_cell(p)
        cellNumberDensity_F.divide_by_cell_volumes()

        # Get an array of the density values
        cellNumberDensityCalc = cellNumberDensity_F.function.vector().get_local()
#        print fncName, "cellNumberDensityCalc =", cellNumberDensityCalc

        # The expected number-density values from test_ChargeDensity.ods:test_2
        cellNumberDensityExpected = np_m.empty(cellNumberDensity_F.function.vector().size(), dtype=np_m.float64)

        # Note that these are in the cell numbering order, not DoF order. We will
        # need to compare cellNumberDensityExpected[cellIndex] with
        # cellNumberDensityCalc[dofIndex], where dofIndex is the DoF number
        # corresponding to cellIndex.
        cellNumberDensityExpected[0] = 0.0
        cellNumberDensityExpected[1] = 4.0e8
        cellNumberDensityExpected[2] = 0.0
        cellNumberDensityExpected[3] = 0.0
        cellNumberDensityExpected[4] = 8.0e8
        cellNumberDensityExpected[5] = 0.0
        cellNumberDensityExpected[6] = 6.0e8
        cellNumberDensityExpected[7] = 0.0

        # Compare results

        for cell in df_m.cells(pmesh2d_M.mesh):
            cellIndex = cell.index()
#            cellVol = mesh_M.cell_volume_dict[cellIndex]
            # There's only 1 DoF in the cell, since this function uses constant DG elements
            dofIndex = cellNumberDensity_F.function_space.dofmap().cell_dofs(cellIndex) # return type: numpy.ndarray
            self.assertAlmostEqual(cellNumberDensityCalc[dofIndex], cellNumberDensityExpected[cellIndex], places=4, msg="Wrong value of cellNumberDensity")

        return
#    def test_2_interpolate_particle_density_to_2Dmesh(self):ENDDEF


#class TestChargeDensity(unittest.TestCase):
    def test_3_compute_charge_density_on_2Dmesh(self):
        """Compute the charge-density generated by line particles on a 2D mesh

           This test is based on the 2D number-density test above.

           Positively and negatively-charged macroparticles are created within a
           2D meshed region and are weighted to nodal points on the mesh.
           The charge-density is then accumulated.
           
           Two species data are defined and segmented-array particle storage is
           used.

           See test_ChargeDensity.ods:test_3 for calculated values of the
           charge-density.

        """

        fncName = '('+__file__+') ' + sys._getframe().f_code.co_name + '():\n'
        print('\ntest: ', fncName, '('+__file__+')')
        

        ########## Numerical Mesh ##########

        ### Describe a 2D mesh from (-10,-10) to (10,10) with 2 cells on a side.
        # The mesh is triangular, so there's a total of 4x2 = 8 cells.
        umi2d_I = UserMeshInput_C()
        umi2d_I.pmin = df_m.Point(-10.0, -10.0)
        umi2d_I.pmax = df_m.Point(10.0, 10.0)
        umi2d_I.cells_on_side = (2, 2)
        umi2d_I.diagonal = 'left'

        ### UserMesh_FE_XYZ_Module can make the mesh from the above input.
        plotFlag = False
        plotTitle = os.path.basename(__file__) + ": " + sys._getframe().f_code.co_name + ": XY mesh"
        # Make the mesh
        mesh2d_M = UserMesh_C(umi2d_I, compute_dictionaries=True, compute_tree=True, plot_flag=plotFlag, plot_title=plotTitle)

        ########## Kinetic particles ##########

        # Create an instance of the DTparticleInput class
        pin = self.pin = ParticleInput_C()
        # Set up particle variables
        pin.precision = np_m.float64

        pin.particle_integration_loop = 'loop-on-particles'
        pin.position_coordinates = ['x', 'y', 'z'] # determines the particle-storage dimensions
        pin.force_components = ['x', 'y', 'z']
        pin.force_precision = np_m.float64

        ### Particle species input

        # Give the properties of the particle species.  The charges and masses
        # are normally those of the physical particles, and not the
        # computational macroparticles.

        speciesName = 'plasma_electrons'
        charge = -1.0*MyPlasmaUnits_C.elem_charge
        mass = 1.0*MyPlasmaUnits_C.electron_mass
        dynamics = 'implicit'
        plasmaElectron_S = ParticleSpecies_C(speciesName, charge, mass, dynamics)

        speciesName = 'H_plus'
        charge = 2.0*MyPlasmaUnits_C.elem_charge
        mass = 1.0*MyPlasmaUnits_C.AMU
        dynamics = 'implicit'
        Hplus_S = ParticleSpecies_C(speciesName, charge, mass, dynamics)

        # Add these two species to particle input
        pin.particle_species = (plasmaElectron_S, Hplus_S,)

        # Make the particle object from pin...
        particles_P = Particle_C(pin, print_flag=False)

        # ...and attach the particle mesh
        particles_P.pmesh_M = mesh2d_M

        ### Create discrete particles

        # Put 3 particles inside the meshed region.

        # Use these for both the electrons and ions. The sign of the electric
        # charge comes from the species info, and is not in the individual
        # particle records.

        x0 = -5.0; y0 = -5.0; z0 = 0.0
        ux0 = 0.0; uy0 = 0.0; uz0 = 0.0
        weight0 = 2.0e10 # number of physical particles per macroparticle
        bitflags0 = 0b0
        cell_index0 = 1
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        # Unlike the previous tests, we're using a Particle_C object here, so
        # the particle tuple has to match the one in Particle_C:
        # ['x','y','z', 'x0','y0','z0', 'ux','uy','uz', 'weight', 'bitflags', 'cell_index', 'unique_ID']
        p0 = (x0,y0,z0, x0,y0,z0, ux0,uy0,uz0, weight0, bitflags0, cell_index0, unique_ID, crossings)

        # 2nd particle
        x1 = 1.0; y1 = 1.0; z1 = 1.0
        ux1 = uy1 = 0.0; uz1 = -uz0
        weight1 = 3.0e10
        bitflags1 = 0b0
        cell_index1 = 6
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        p1 = (x1,y1,z1, x1,y1,z1, ux1,uy1,uz1, weight1, bitflags1, cell_index1, unique_ID, crossings)

        # 3nd particle
        x2 = -9.0; y2 = 1.0; z2 = 1.0
        ux2 = uy2 = 0.0; uz2 = -uz0
        weight2 = 4.0e10
        bitflags2 = 0b0
        cell_index2 = 4 # Particle lies on boundary between 0 and 1
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        p2 = (x2,y2,z2, x2,y2,z2, ux2,uy2,uz2, weight2, bitflags2, cell_index2, unique_ID, crossings)

        particle_list = (p0, p1, p2)

        ### Put these particles into storage

        # Electrons
        species_name = 'plasma_electrons'

        number_of_macroparticles = len(particle_list)

        pseg_arr = particles_P.pseg_arr[species_name] # The SegmentedArray_C object for this species

        for i in range(number_of_macroparticles):
#            print 'species_name, particle_list[i] = ', species_name, particle_list[i]
            p, pindex = pseg_arr.put(particle_list[i])

        # Ions
        species_name = 'H_plus'

        number_of_macroparticles = 3

        pseg_arr = particles_P.pseg_arr[species_name] # The SegmentedArray_C object for this species

        for i in range(number_of_macroparticles):
#            print 'species_name, particle_list[i] = ', species_name, particle_list[i]
            p, pindex = pseg_arr.put(particle_list[i])


        ########## Source for the electric field ##########

        # Allocate storage for the number-density obtained from kinetic
        # particles.  The number-density array stores the integral of the
        # physical density-distribution times the element basis functions.

        dofNumberDensityElementType = 'Lagrange'
        dofNumberDensityElementDegree = 1
        dofNumberDensityFieldType = 'scalar'
        dofNumberDensityDict_F = {s: None for s in particles_P.species_names}

        for s in particles_P.species_names:
#            particles_P.dof_number_density_dict[s] = Field_C(particles_P.pmesh_M,
            dofNumberDensityDict_F[s] = Field_C(particles_P.pmesh_M,
                                                element_type=dofNumberDensityElementType,
                                                element_degree=dofNumberDensityElementDegree,
                                                field_type=dofNumberDensityFieldType)

            ## Accumulate density from kinetic particles of this species
            particles_P.accumulate_number_density(s, dofNumberDensityDict_F[s])

        ## Create a charge-density array on the field mesh ##
        chargeDensity_F = Field_C(mesh2d_M,
                                  element_type=dofNumberDensityElementType,
                                  element_degree=dofNumberDensityElementDegree,
                                  field_type=dofNumberDensityFieldType)

        ## Compute the charge-density
        ## (See sphere1D.py for an alternative to this)
        particles_P.accumulate_charge_density_from_particles(dofNumberDensityDict_F, chargeDensity_F)

        chargeDensityCalc = chargeDensity_F.function.vector().get_local()
#        print fncName, dofNumberDensityCalc

        # The expected number-density values from test_ChargeDensity.ods:test_3
        # Note that these are in the vertex numbering order, not DoF order. We will
        # need to compare dofNumberDensityExpected[ivert] with dofNumberDensityCalc[idof],
        # where idof is the DoF number corresponding to ivert (see conversion below).
        chargeDensityExpected = np_m.empty(chargeDensity_F.function.vector().size(), dtype=np_m.float64)

        # NB: These are in vertex, not DOF order
        chargeDensityExpected[0] = 0.0
        chargeDensityExpected[1] = 1.602176487E-009
        chargeDensityExpected[2] = 0.0
        chargeDensityExpected[3] = 6.7291412454E-009
        chargeDensityExpected[4] = 4.4860941636E-009
        chargeDensityExpected[5] = 4.806529461E-010
        chargeDensityExpected[6] = 6.408705948E-010
        chargeDensityExpected[7] = 4.806529461E-010
        chargeDensityExpected[8] = 0.0


        # Compare results
        functionSpace = chargeDensity_F.function_space
        gdim = chargeDensity_F.mesh_gdim
        # Reshape the coordinates to get (x), or (x,y), or (x,y,z) tuples.
        if df_m.__version__ > "1.5.0":
            dofcoords = functionSpace.tabulate_dof_coordinates().reshape((-1, gdim))
        else:
            print('\n!!!WARNING!!!: ', fncName, ": DOLFIN too old.  Skipping rest of test")
            return

#        print "dofcoords=", dofcoords

        # Plot the result

        plotTitle = os.path.basename(__file__) + ": " + sys._getframe().f_code.co_name + ": charge density"
        df_m.plot(chargeDensity_F.function, title=plotTitle)
        mplot_m.show()
#        yesno = raw_input("Just called show() in test_3_compute_charge_density_on_2Dmesh")
        
        ## Check the values vs. those computed in test_ChargeDensity.ods:test_3

        # Convert vertex indices to DoF indices.  For CG1 elements, there are
        # the same number of vertices as DoFs.
        v2d=df_m.vertex_to_dof_map(functionSpace)

        for ivert in range(len(chargeDensityExpected)):
            idof = v2d[ivert]
#            print "vertex", ivert, "is DoF index", idof
#            print "chargeDensityCalc, chargeDensityExpected =", chargeDensityCalc[idof], chargeDensityExpected[ivert]
            # "places" means numbers after the decimal point:
            self.assertAlmostEqual(chargeDensityCalc[idof], chargeDensityExpected[ivert], places=4, msg="Wrong value of charge density")
        return
#    def test_3_compute_charge_density_on_2Dmesh(self):ENDDEF


#class TestChargeDensity(unittest.TestCase):
    def test_4_compute_charge_density_on_1Dmesh(self):
        """Compute the charge-density generated by line particles on a 1D mesh

           This test is based on the 1D number-density test above.

           Positively and negatively-charged macroparticles are created within a
           1D meshed region and are weighted to nodal points on the mesh.
           The charge-density is then accumulated.
           
           Two species data are defined and segmented-array particle storage is
           used.

           See test_FieldSolve.ods:test_4 for calculated values of the
           charge-density.

        """

        fncName = '('+__file__+') ' + sys._getframe().f_code.co_name + '():\n'
        print('\ntest: ', fncName, '('+__file__+')')
        

        ########## Numerical Mesh ##########

        # Describe a 1D mesh over [-0.5 ,0.5] with 2 cells.
        umi1D = UserMeshInput_C()
        umi1D.pmin = df_m.Point(-0.5)
        umi1D.pmax = df_m.Point(0.5)
        umi1D.cells_on_side = (2,)

        # Name the Dirichlet boundaries and assign integers to them.
        # These are the boundary-name -> int pairs used to mark mesh
        # facets:
        xminIndx = 1
        xmaxIndx = 2
        fieldBoundaryDict = {'xmin': xminIndx,
                             'xmax': xmaxIndx,
                             }

        umi1D.field_boundary_dict = fieldBoundaryDict

        # UserMesh_FE_XYZ_Module can make the mesh from the above input.
        plotFlag = False
        plotTitle = os.path.basename(__file__) + ": " + sys._getframe().f_code.co_name + ": XY mesh"
        mesh1d_M = UserMesh_C(umi1D, compute_dictionaries=True, compute_tree=True, plot_flag=plotFlag, plot_title=plotTitle)

        ########## Kinetic particles ##########

        # Create an instance of the DTparticleInput class
        pin = self.pin = ParticleInput_C()
        # Set up particle variables
        pin.precision = np_m.float64

        pin.particle_integration_loop = 'loop-on-particles'
        pin.position_coordinates = ['x', 'y', 'z'] # determines the particle-storage dimensions
        pin.force_components = ['x', 'y', 'z']
        pin.force_precision = np_m.float64

        ### Particle species input

        # Give the properties of the particle species.  The charges and masses
        # are normally those of the physical particles, and not the
        # computational macroparticles.

        speciesName = 'plasma_electrons'
        charge = -1.0*MyPlasmaUnits_C.elem_charge
        mass = 1.0*MyPlasmaUnits_C.electron_mass
        dynamics = 'explicit'
        plasmaElectron_S = ParticleSpecies_C(speciesName, charge, mass, dynamics)

        # Add this species to particle input
        pin.particle_species = (plasmaElectron_S,)

        # Make the particle object from pin...
        particles_P = Particle_C(pin, print_flag=False)

        # ...and attach the particle mesh.
        particles_P.pmesh_M = mesh1d_M

        ### Create discrete particles

        # Put 1 particles in the meshed region.

        x0 = 0.0; y0 = 0.0; z0 = 0.0
        ux0 = 0.0; uy0 = 0.0; uz0 = 0.0
        weight0 = 5.52623e7 # to get 1 V/m jump in E prev: 4.0e10 # number of electrons per macroparticle
        bitflags0 = 0b0
        cell_index0 = 1
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        # The particle tuple has to match the one in Particle_C:
        # ['x','y','z', 'x0','y0','z0', 'ux','uy','uz', 'weight', 'bitflags', 'cell_index', 'unique_ID']
        p0 = (x0,y0,z0, x0,y0,z0, ux0,uy0,uz0, weight0, bitflags0, cell_index0, unique_ID, crossings)

        particle_list = (p0,)

        ### Put these particles into storage

        # Electrons
        species_name = 'plasma_electrons'

        number_of_macroparticles = len(particle_list)

        pseg_arr = particles_P.pseg_arr[species_name] # The SegmentedArray_C object for this species

        for i in range(number_of_macroparticles):
#            print 'species_name, particle_list[i] = ', species_name, particle_list[i]
            p, pindex = pseg_arr.put(particle_list[i])

        ########## Source for the electric field ##########

        # Allocate storage for the number-density obtained from kinetic
        # particles.  The number-density array stores the integral of the
        # physical density-distribution times the element basis functions.

        dofNumberDensityElementType = 'Lagrange'
        dofNumberDensityElementDegree = 1
        dofNumberDensityFieldType = 'scalar'
        dofNumberDensityDict_F = {s: None for s in particles_P.species_names}
        
        for s in particles_P.species_names:
            dofNumberDensityDict_F[s] = Field_C(particles_P.pmesh_M,
                                                element_type=dofNumberDensityElementType,
                                                element_degree=dofNumberDensityElementDegree,
                                                field_type=dofNumberDensityFieldType)

        ## Create a charge-density vector ##
        chargeDensity_F = Field_C(mesh1d_M,
                                  element_type=dofNumberDensityElementType,
                                  element_degree=dofNumberDensityElementDegree,
                                  field_type=dofNumberDensityFieldType)

        ## Accumulate number-density from kinetic particles of this species
        ## and sum charge-density.
        for s in particles_P.species_names:
            particles_P.accumulate_number_density(s, dofNumberDensityDict_F[s])
            q = particles_P.charge[s]
            chargeDensity_F.multiply_add(dofNumberDensityDict_F[s], q)

        chargeDensityCalc = chargeDensity_F.function.vector().get_local()
#        print fncName, dofNumberDensityCalc

        # The expected charge-density values from test_ChargeDensity.ods:test_4
        # Note that these are in the vertex numbering order, not DoF order. We will
        # need to compare dofNumberDensityExpected[ivert] with dofNumberDensityCalc[idof],
        # where idof is the DoF number corresponding to ivert (see conversion below).
        chargeDensityExpected = np_m.empty(chargeDensity_F.function.vector().size(), dtype=np_m.float64)

        # These are in vertex, not DOF order
        chargeDensityExpected[0] = 0.0
        chargeDensityExpected[1] = -8.85418782e-12 # prev: -6.408705948E-09
        chargeDensityExpected[2] = 0.0

        # Compare results
        functionSpace = chargeDensity_F.function_space
        gdim = chargeDensity_F.mesh_gdim
        # Reshape the coordinates to get (x), or (x,y), or (x,y,z) tuples.
        if df_m.__version__ > "1.5.0":
            dofcoords = functionSpace.tabulate_dof_coordinates().reshape((-1, gdim))
        else:
            print('\n!!!WARNING!!!: ', fncName, ": DOLFIN too old.  Skipping rest of test")
            return

#        print "dofcoords=", dofcoords

        # Convert vertex indices to DoF indices.  For CG1 elements, there are
        # the same number of vertices as DoFs.
        v2d=df_m.vertex_to_dof_map(functionSpace)

        ## Check the charge source-vector values vs. those computed in test_ChargeDensity.ods:test_4
        for ivert in range(len(chargeDensityExpected)):
            idof = v2d[ivert]
#            print "vertex", ivert, "is DoF index", idof
#            print "chargeDensityCalc, chargeDensityExpected =", chargeDensityCalc[idof], chargeDensityExpected[ivert]
            # "places" means numbers after the decimal point:
            self.assertAlmostEqual(chargeDensityCalc[idof], chargeDensityExpected[ivert], places=4, msg="Wrong value of charge density")


        # Write the mesh to a file:
        mesh_file = df_m.File('mesh_2cell_1D.xml')
        mesh_file << mesh1d_M.mesh

        # Write the boundary marker function to a file:
        field_boundary_marker_file = df_m.File('mesh_2cell_1D_Fbcs.xml')
        field_boundary_marker_file << mesh1d_M.field_boundary_marker
#        # Read back in:
#        field_boundary_marker_file >> mesh1d_M.field_boundary_marker

        ## Write out the charge source-vector:
        file = df_m.File("charge_1D.xml")
        file << chargeDensity_F.function

        # Use XDMF format
        mesh_file = df_m.XDMFFile("mesh_2cell_1D.xdmf")
        mesh_file.write(mesh1d_M.mesh)

        return
#    def test_4_compute_charge_density_on_1Dmesh(self):ENDDEF

#class TestChargeDensity(unittest.TestCase):
    def test_5_compute_charge_density_on_1D_spherical_mesh(self):
        """Compute the charge-density generated by line particles on a spherical 1D
           radial mesh.

           One macroparticle with -1C of charge is placed on the 1D mesh and weighted
           to nodal points on the mesh.  The charge-density is then accumulated, and
           written to a file.
           
           The values calculated below are compared to the values computed by hand in
           test_FieldSolve.ods:test_5.

           :cvar str speciesName: An unique name for the species.
           :cvar double x0: The radial location of the test particle.

           :cvar int places: The number of digits after the decimal point used in
                             comparing values.
        """

        fncName = '('+__file__+') ' + sys._getframe().f_code.co_name + '():\n'
        print('\ntest: ', fncName, '('+__file__+')')
        
        coordinateSystem = '1D-spherical-radius'

        ########## Numerical Mesh ##########

        ### Specialized mesh and field-solver modules for this test ###

        from UserMesh_y_Fields_Spherical1D_Module import UserMeshInput1DS_C
        from UserMesh_y_Fields_Spherical1D_Module import UserMesh1DS_C
        from UserMesh_y_Fields_Spherical1D_Module import UserPoissonSolve1DS_C

        umi1DS_I = UserMeshInput1DS_C()
        umi1DS_I.mesh_file = 'mesh_1D_radial.xml'
        umi1DS_I.field_boundary_marker_file = 'mesh_1D_radial_Fbcs.xml'

        ### Set plot flag ###

        if os.environ.get('DISPLAY') is None:
            plotFlag=False
        else:
            plotFlag=True

        ### Read the mesh and boundary-condition markers ###

        # Create a mesh object and read in the mesh.
        mesh1d_M = UserMesh1DS_C(umi1DS_I, compute_dictionaries=True, compute_tree=True, plot_flag=False)

        ########## Kinetic particles ##########

        # Create an instance of the DTparticleInput class
        pin = self.pin = ParticleInput_C()

        pin.precision = np_m.float64
        pin.particle_integration_loop = 'loop-on-particles'
        pin.coordinate_system = coordinateSystem
        pin.position_coordinates = ['x',] # determines the particle-storage dimensions. This
                                          # is doubled to get the phase-space coordinates
        pin.force_components = ['x',]
        pin.force_precision = np_m.float64

        ### Particle species input

        # Give the properties of the particle species.  The charges and masses
        # are normally those of the physical particles, and not the
        # computational macroparticles.

        speciesName = 'plasma_electrons'
        charge = -1.0*MyPlasmaUnits_C.elem_charge
        mass = 1.0*MyPlasmaUnits_C.electron_mass
        dynamics = 'explicit'
        plasmaElectron_S = ParticleSpecies_C(speciesName, charge, mass, dynamics)

        # Add these two species to particle input
        pin.particle_species = (plasmaElectron_S,)

        # Make the particle object from pin...
        particles_P = Particle_C(pin, print_flag=False)

        # ...and attach the particle mesh.
        particles_P.pmesh_M = mesh1d_M

        ### Create discrete particles

        # Put 1 plasma_electron in the first cell.
#        x0 = 1.05
#        cell_index0 = 0
        # Put 1 plasma_electron at 2 m
        x0 = 2.0
        cell_index0 = 3 # This value is checked below.

        ux0 = 0.0
        weight0 = 1.0/MyPlasmaUnits_C.elem_charge # to get 1 C of charge
        weight0 /= 4.0*np_m.pi # charge per steradian
        bitflags0 = 0b0
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        # The particle tuple has to match the one in Particle_C:
        # ['x','y','z', 'x0','y0','z0', 'ux','uy','uz', 'weight', 'bitflags', 'cell_index', 'unique_ID']
        p0 = (x0, x0, ux0, weight0, bitflags0, cell_index0, unique_ID, crossings)

        particle_list = (p0, )

        ### Put the particle into storage

        # Electrons
        species_name = 'plasma_electrons'

        number_of_macroparticles = len(particle_list)

        pseg_arr = particles_P.pseg_arr[species_name] # The SegmentedArray_C object for this species

        for i in range(number_of_macroparticles):
#            print 'species_name, particle_list[i] = ', species_name, particle_list[i]
            p, pindex = pseg_arr.put(particle_list[i])

        # Check that we set the right cell index above
        computed_cell_index = particles_P.pmesh_M.compute_cell_index(p)
        if cell_index0 != computed_cell_index:
            errorMsg = "%s Particle cell index should be %d, not %d" % (fncName, computed_cell_index, cell_index0)
            sys.exit(errorMsg)

        ########## Source for the electric field ##########

        # Allocate storage for the number-density obtained from kinetic
        # particles.  The number-density array stores the integral of the
        # physical density-distribution times the element basis functions.

        dofNumberDensityElementType = 'Lagrange'
        dofNumberDensityElementDegree = 1
        dofNumberDensityFieldType = 'scalar'
        dofNumberDensityDict_F = {s: None for s in particles_P.species_names}        

        for s in particles_P.species_names:
            dofNumberDensityDict_F[s] = Field_C(particles_P.pmesh_M,
                                                element_type=dofNumberDensityElementType,
                                                element_degree=dofNumberDensityElementDegree,
                                                field_type=dofNumberDensityFieldType)

        ## Create a charge-density vector ##
        chargeDensity_F = Field_C(mesh1d_M,
                                  element_type=dofNumberDensityElementType,
                                  element_degree=dofNumberDensityElementDegree,
                                  field_type=dofNumberDensityFieldType)

        ## Accumulate number-density from kinetic particles of this species
        ## and sum charge-density.
        for s in particles_P.species_names:
            particles_P.accumulate_number_density(s, dofNumberDensityDict_F[s])
            q = particles_P.charge[s]
            chargeDensity_F.multiply_add(dofNumberDensityDict_F[s], q)

#        print "dofNumberDensityCalc =", dofNumberDensityDict_F['plasma_electrons'].function.vector().array()

        chargeDensityCalc = chargeDensity_F.function.vector().get_local()
#        print fncName, dofNumberDensityCalc

        # The expected charge-density values are computed in
        # test_ChargeDensity.ods:test_5. Note that these are in the vertex numbering
        # order, not DoF order. As a result we need to compare
        # dofNumberDensityExpected[ivert] with dofNumberDensityCalc[idof], where idof is
        # the DoF number corresponding to ivert (see conversion below).

        # Create a numpy array for the charge density values.
        chargeDensityExpected = np_m.empty(chargeDensity_F.function.vector().size(), dtype=np_m.float64)

        chargeDensityExpected[0:11] = 0.0 # First, zero out the values
        # Set the values computed in test_ChargeDensity.ods:test_5
        chargeDensityExpected[3] = -4.52095e-2 # -1 C at 2 m
        chargeDensityExpected[4] = -3.43680e-2
#        chargeDensityExpected[0] = -5.97302e-2 # -1 C at 1.05 m
#        chargeDensityExpected[1] = -1.98472e-2
 
        functionSpace = chargeDensity_F.function_space

        # Get the (x,y,z) coordinates of the DoFs for inspection (only).
        # Reshape the coordinates to get (x), or (x,y), or (x,y,z) tuples.
        gdim = chargeDensity_F.mesh_gdim
        if df_m.__version__ > "1.5.0":
            dofcoords = functionSpace.tabulate_dof_coordinates().reshape((-1, gdim))
        else:
            print('\n!!!WARNING!!!: ', fncName, ": DOLFIN too old.  Skipping rest of test")
            return
#        print "dofcoords=", dofcoords

        # Convert vertex indices to DoF indices.  For CG1 elements, there are the
        # same number of vertices as DoFs.
        v2d=df_m.vertex_to_dof_map(functionSpace)

        ## Check the charge source-vector values vs. those computed in
        ## test_ChargeDensity.ods:test_5
#        print "chargeDensityCalc =", chargeDensityCalc
#        print "chargeDensityExpected =", chargeDensityExpected
        for ivert in range(len(chargeDensityExpected)):
            idof = v2d[ivert]
#            print "vertex", ivert, "is DoF index", idof
#            print "chargeDensityCalc, chargeDensityExpected =", chargeDensityCalc[idof], chargeDensityExpected[ivert]
            # "places" means numbers after the decimal point:
            self.assertAlmostEqual(chargeDensityCalc[idof], chargeDensityExpected[ivert], places=4, msg="Wrong value of charge density")

        ## Write out the charge source-vector:
        file = df_m.File("charge_1DS.xml")
        file << chargeDensity_F.function

        return
#    def test_5_compute_charge_density_on_1D_spherical_mesh(self):ENDDEF

#class TestChargeDensity(unittest.TestCase):
    def test_6_compute_charge_density_on_1D_spherical_mesh(self):
        """Compute the charge-density generated by a particle at r = 0 on a spherical 1D
           radial mesh.

           One macroparticle with -1C of charge is placed at r = 0 and weighted
           to nodal points on the mesh.  The charge-density is then accumulated, and
           written to a file.
           
           The values calculated below are compared to the values computed by hand in
           test_FieldSolve.ods:test_6.

           :cvar str speciesName: An unique name for the species.
           :cvar double x0: The radial location of the test particle.

           :cvar int places: The number of digits after the decimal point used in
                             comparing values.
        """

        fncName = '('+__file__+') ' + sys._getframe().f_code.co_name + '():\n'
        print('\ntest: ', fncName, '('+__file__+')')
        
        coordinateSystem = '1D-spherical-radius'

        ########## Numerical Mesh ##########

        ### Specialized mesh and field-solver modules for this test ###

        from UserMesh_y_Fields_Spherical1D_Module import UserMeshInput1DS_C
        from UserMesh_y_Fields_Spherical1D_Module import UserMesh1DS_C
        from UserMesh_y_Fields_Spherical1D_Module import UserPoissonSolve1DS_C

        umi1DS_I = UserMeshInput1DS_C()
        umi1DS_I.mesh_file = 'mesh_1D_radial_r0.xml'
        umi1DS_I.field_boundary_marker_file = 'mesh_1D_radial_r0_Fbcs.xml'

        ### Set plot flag ###

        if os.environ.get('DISPLAY') is None:
            plotFlag=False
        else:
            plotFlag=True

        ### Read the mesh and boundary-condition markers ###

        # Create a mesh object and read in the mesh.
        mesh1d_M = UserMesh1DS_C(umi1DS_I, compute_dictionaries=True, compute_tree=True, plot_flag=False)

        ########## Kinetic particles ##########

        # Create an instance of the DTparticleInput class
        pin = self.pin = ParticleInput_C()

        pin.precision = np_m.float64
        pin.particle_integration_loop = 'loop-on-particles'
        pin.coordinate_system = coordinateSystem
        pin.position_coordinates = ['x',] # determines the particle-storage dimensions. This
                                          # is doubled to get the phase-space coordinates
        pin.force_components = ['x',]
        pin.force_precision = np_m.float64

        ### Particle species input

        # Give the properties of the particle species.  The charges and masses
        # are normally those of the physical particles, and not the
        # computational macroparticles.

        speciesName = 'plasma_electrons'
        charge = -1.0*MyPlasmaUnits_C.elem_charge
        mass = 1.0*MyPlasmaUnits_C.electron_mass
        dynamics = 'explicit'
        plasmaElectron_S = ParticleSpecies_C(speciesName, charge, mass, dynamics)

        # Add these two species to particle input
        pin.particle_species = (plasmaElectron_S,)

        # Make the particle object from pin...
        particles_P = Particle_C(pin, print_flag=False)

        # ...and attach the particle mesh.
        particles_P.pmesh_M = mesh1d_M

        ### Create discrete particles

        # Put 1 plasma_electron in the first cell.
#        x0 = 1.05
#        cell_index0 = 0
        # Put 1 plasma_electron at r = 0
        x0 = 0.0
        cell_index0 = 0 # This value is checked below.

        ux0 = 0.0
        weight0 = 1.0/MyPlasmaUnits_C.elem_charge # to get 1 C of charge
        weight0 /= 4.0*np_m.pi # charge per steradian
        bitflags0 = 0b0
        unique_ID = Particle_C.UNIQUE_ID_COUNTER; Particle_C.UNIQUE_ID_COUNTER += 1
        crossings = 0

        # The particle tuple has to match the one in Particle_C:
        # ['x','y','z', 'x0','y0','z0', 'ux','uy','uz', 'weight', 'bitflags', 'cell_index', 'unique_ID']
        p0 = (x0, x0, ux0, weight0, bitflags0, cell_index0, unique_ID, crossings)

        particle_list = (p0, )

        ### Put the particle into storage

        # Electrons
        species_name = 'plasma_electrons'

        number_of_macroparticles = len(particle_list)

        pseg_arr = particles_P.pseg_arr[species_name] # The SegmentedArray_C object for this species

        for i in range(number_of_macroparticles):
#            print 'species_name, particle_list[i] = ', species_name, particle_list[i]
            p, pindex = pseg_arr.put(particle_list[i])

        # Check that we set the right cell index above
        computed_cell_index = particles_P.pmesh_M.compute_cell_index(p)
        if cell_index0 != computed_cell_index:
            errorMsg = "%s Particle cell index should be %d, not %d" % (fncName, computed_cell_index, cell_index0)
            sys.exit(errorMsg)

        ########## Source for the electric field ##########

        # Allocate storage for the number-density obtained from kinetic
        # particles.  The number-density array stores the integral of the
        # physical density-distribution times the element basis functions.

        dofNumberDensityElementType = 'Lagrange'
        dofNumberDensityElementDegree = 1
        dofNumberDensityFieldType = 'scalar'
        dofNumberDensityDict_F = {s: None for s in particles_P.species_names}

        for s in particles_P.species_names:
            dofNumberDensityDict_F[s] = Field_C(particles_P.pmesh_M,
                                                element_type=dofNumberDensityElementType,
                                                element_degree=dofNumberDensityElementDegree,
                                                field_type=dofNumberDensityFieldType)

        ## Create a charge-density vector ##
        chargeDensity_F = Field_C(mesh1d_M,
                                  element_type=dofNumberDensityElementType,
                                  element_degree=dofNumberDensityElementDegree,
                                  field_type=dofNumberDensityFieldType)

        ## Accumulate number-density from kinetic particles of this species
        ## and sum charge-density.
        for s in particles_P.species_names:
            particles_P.accumulate_number_density(s, dofNumberDensityDict_F[s])
            q = particles_P.charge[s]
            chargeDensity_F.multiply_add(dofNumberDensityDict_F[s], q)

#        print "dofNumberDensityCalc =", dofNumberDensityDict_F['plasma_electrons'].function.vector().array()

        chargeDensityCalc = chargeDensity_F.function.vector().get_local()
#        print fncName, dofNumberDensityCalc

        # The expected charge-density values are computed in
        # test_ChargeDensity.ods:test_6. Note that these are in the vertex numbering
        # order, not DoF order. As a result we need to compare
        # dofNumberDensityExpected[ivert] with dofNumberDensityCalc[idof], where idof is
        # the DoF number corresponding to ivert (see conversion below).

        # Create a numpy array for the charge density values.
        chargeDensityExpected = np_m.empty(chargeDensity_F.function.vector().size(), dtype=np_m.float64)

        chargeDensityExpected[0:11] = 0.0 # First, zero out the values
        # Set the values computed in test_ChargeDensity.ods:test_6
        chargeDensityExpected[0] = -7.95775e-2 # -1 C at r = 0 m
        chargeDensityExpected[1] = 0.0
 
        functionSpace = chargeDensity_F.function_space

        # Get the (x,y,z) coordinates of the DoFs for inspection (only).
        # Reshape the coordinates to get (x), or (x,y), or (x,y,z) tuples.
        gdim = chargeDensity_F.mesh_gdim
        if df_m.__version__ > "1.5.0":
            dofcoords = functionSpace.tabulate_dof_coordinates().reshape((-1, gdim))
        else:
            print('\n!!!WARNING!!!: ', fncName, ": DOLFIN too old.  Skipping rest of test")
            return
#        print "dofcoords=", dofcoords

        # Convert vertex indices to DoF indices.  For CG1 elements, there are the
        # same number of vertices as DoFs.
        v2d=df_m.vertex_to_dof_map(functionSpace)

        ## Check the charge source-vector values vs. those computed in
        ## test_ChargeDensity.ods:test_6
#        print "chargeDensityCalc =", chargeDensityCalc
#        print "chargeDensityExpected =", chargeDensityExpected
        for ivert in range(len(chargeDensityExpected)):
            idof = v2d[ivert]
#            print "vertex", ivert, "is DoF index", idof
#            print "chargeDensityCalc, chargeDensityExpected =", chargeDensityCalc[idof], chargeDensityExpected[ivert]
            # "places" means numbers after the decimal point:
            self.assertAlmostEqual(chargeDensityCalc[idof], chargeDensityExpected[ivert], places=4, msg="Wrong value of charge density")

        ## Write out the charge source-vector:
        file = df_m.File("charge_1DS_r0.xml")
        file << chargeDensity_F.function

        return
#    def test_6_compute_charge_density_on_1D_spherical_mesh(self):ENDDEF

#class TestChargeDensity(unittest.TestCase):ENDCLASS

if __name__ == '__main__':
    unittest.main()
